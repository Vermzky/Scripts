if game.PlaceId == 79940517734440 then
    local getgenv = getfenv().getgenv

    getgenv().ScriptVersion = "v1.0"

    loadstring(game:HttpGet("https://raw.githubusercontent.com/Vermzky/VermzHub/refs/heads/main/UI"))()

    local firetouchinterest = getgenv().firetouchinterest
    local firesignal = getgenv().firesignal
    local fireclickdetector = getgenv().fireclickdetector
    local hookmetamethod = getgenv().hookmetamethod
    local getnamecallmethod = getgenv().getnamecallmethod
    local checkcaller = getgenv().checkcaller    

    local UnsupportedName = getgenv().UnsupportedName
    local ApplyUnsupportedName = getgenv().ApplyUnsupportedName
    local HandleConnection = getgenv().HandleConnection
    local Notify = getgenv().Notify    

    local Rayfield = getgenv().Rayfield

    ------------- /////// SERVICES \\\\\\\ -------------
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local VirtualInputManager = game:GetService("VirtualInputManager")

    local player = Players.LocalPlayer
    local char = player.Character
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    local playerGui = player:WaitForChild("PlayerGui")

    player.CharacterAdded:Connect(function(char)
        character = char
        hrp = char:WaitForChild("HumanoidRootPart")
    end)

    --Kill Aura and Mob
    local ATTACK_DELAY = 0.1
    local ATTACK_RANGE = 100
    local MAX_DISTANCE = 50

    --Dungeon
    local leaveFloor = 0
    local startFloor = 1

    --Sell
    local autoSellThreshold = 50

    --Skills
    local TABLE_ADD_AMOUNT = 800
    local AttackPerSecond = 8
    
    local selectedUpgrade = ""
    local selectedEgg = ""
    local selectedMap = ""
    local selectedEnchantItem = ""
    local selectedSkills = {}
    local selectedSocket = {}

    local isKillAura = false
    local isKillAuraPlayer = false
    local isAutoMob = false
    local isAutoUpgrade = false
    local isAutoDungeon = false
    local isAutoLeave = false
    local isAutoBlock = false
    local isAutoSkills = false
    local isAutoRebirth = false
    local isAutoCraftSocket = false
    local isAutoSell = false
    --Relic
    local isAutoDeleteRelic = false
    local hasDeleted = false

    --Event
    local isAutoEnchantFast = false
    local isAutoEventEgg = false
    local isAutoEventClaim = false
    local autoEnchantThread = nil

    local dungeonThread = nil
    local checkingThread

    ------------- /////// Teleport \\\\\\\ ------------- 
    local mapNames = {
        ["World 1"] = "1",
        ["World 2"] = "2",
        ["World 3"] = "3",
        ["World 4"] = "4",
        ["World 5"] = "5",
        ["World 6"] = "6",
        ["World 7"] = "7",
        ["World 8"] = "8",
        ["World 9"] = "9",
        ["Dungeon"] = "999"
    }

    ------------- /////// KILL AURA \\\\\\\ ------------- 
    local mobFolder = workspace:WaitForChild("Live"):WaitForChild("Mob")
    local remote = ReplicatedStorage:WaitForChild("Remote"):WaitForChild("Event"):WaitForChild("Combat"):WaitForChild("M1")
    local currentTarget = nil

    local function getHRP()
        local char = player.Character
        return char and char:FindFirstChild("HumanoidRootPart")
    end

    local function isMobAlive(mob)
        return mob
            and mob.Parent
            and mob:GetAttribute("Health")
            and mob:GetAttribute("Health") > 0
            and mob:IsA("BasePart")
    end

    task.spawn(function()
        while true do
            if isKillAura then
                local hrp = getHRP()
                if hrp then
                    local mobsToAttack = {}

                    for _, mob in ipairs(mobFolder:GetChildren()) do
                        if isMobAlive(mob) then
                            local distance = (hrp.Position - mob.Position).Magnitude
                            if distance <= ATTACK_RANGE then
                                for i = 1, TABLE_ADD_AMOUNT do
                                    table.insert(mobsToAttack, mob.Name)
                                end
                            end
                        end
                    end

                    if #mobsToAttack > 0 then
                        local args = { mobsToAttack }
                        remote:FireServer(unpack(args))
                    end
                end
            end
            task.wait(ATTACK_DELAY)
        end
    end)

    ------------- /////// KILL AURA PLAYER \\\\\\\ -------------
    local PVPDamageRemote = ReplicatedStorage:WaitForChild("Remote"):WaitForChild("Event"):WaitForChild("PVP"):WaitForChild("[C-S]PVPDamage")

    local function getClosestPlayer()
        local character = player.Character
        if not character then return nil end

        local hrp = character:FindFirstChild("HumanoidRootPart")
        if not hrp then return nil end

        local closestPlayer = nil
        local closestDistance = MAX_DISTANCE

        for _, targetPlayer in ipairs(Players:GetPlayers()) do
            if targetPlayer ~= player and targetPlayer.Character then 
                local targetHRP = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
                local humanoid = targetPlayer.Character:FindFirstChildOfClass("Humanoid")

                if targetHRP and humanoid and humanoid.Health > 0 then
                    local distance = (targetHRP.Position - hrp.Position).Magnitude
                    if distance <= closestDistance then
                        closestDistance = distance
                        closestPlayer = targetPlayer
                    end
                end
            end
        end

        return closestPlayer
    end

    task.spawn(function()
        while true do
            if isKillAuraPlayer then
                local target = getClosestPlayer()
                if target then
                    PVPDamageRemote:FireServer({ target })
                end
            end
            task.wait(ATTACK_DELAY)
        end
    end)

    ------------- /////// AUTO MOB \\\\\\\ -------------

    local FLOAT_OFFSET = Vector3.new(25, 0, 0)
    local currentMob = nil
    local originalCanCollide = {}

    local function lockCamera()
        if char and char:FindFirstChild("Humanoid") then
            char.Humanoid.CameraOffset = Vector3.zero
        end
    end

    local function stabilizeHumanoid()
        local hum = char and char:FindFirstChild("Humanoid")
        if hum then
            hum.PlatformStand = false
            hum.Sit = false
        end
    end

    local function saveOriginalCollisions()
        originalCanCollide = {}
        if not char then return end

        for _, part in ipairs(char:GetDescendants()) do
            if part:IsA("BasePart") then
                originalCanCollide[part] = part.CanCollide
            end
        end
    end

    local function disableCollisions()
        for part, _ in pairs(originalCanCollide) do
            if part and part.Parent and part:IsA("BasePart") then
                part.CanCollide = false
            end
        end
    end

    local function restoreCollisions()
        for part, state in pairs(originalCanCollide) do
            if part and part.Parent and part:IsA("BasePart") then
                part.CanCollide = state
            end
        end
    end

    local function isValidMob(mob)
        if not mob or not mob.Parent then return false end
        if not mob:FindFirstChild("HumanoidRootPart") then return false end

        local hp = mob:GetAttribute("Health")
        if not hp or hp <= 0 then return false end

        return true
    end

    local function getSpawnedMobs()
        local mobs = {}
        local folder = workspace:WaitForChild("Live"):WaitForChild("MobModel")

        for _, mob in ipairs(folder:GetChildren()) do
            if mob:IsA("Model") and isValidMob(mob) then
                local id = mob:GetAttribute("Id")
                if id ~= "M0" then
                    table.insert(mobs, mob)
                end
            end
        end

        return mobs
    end

    local function teleportToMob(mob)
        local hrpMob = mob:FindFirstChild("HumanoidRootPart")
        if not hrpMob or not hrp then return end

        hrp.CFrame = CFrame.new(hrpMob.Position + FLOAT_OFFSET)
        hrp.AssemblyLinearVelocity = Vector3.zero
        stabilizeHumanoid()
        lockCamera()
    end

    player.CharacterAdded:Connect(function(newChar)
        char = newChar
        hrp = char:WaitForChild("HumanoidRootPart")

        currentMob = nil
        saveOriginalCollisions()
        stabilizeHumanoid()
        lockCamera()
    end)

    task.spawn(function()
        while task.wait(0.15) do
            if not isAutoMob or not hrp then
                currentMob = nil
                restoreCollisions()
            else
                disableCollisions()

                if not isValidMob(currentMob) then
                    currentMob = nil
                end

                if not currentMob then
                    local mobs = getSpawnedMobs()
                    if #mobs > 0 then
                        currentMob = mobs[math.random(#mobs)]
                        teleportToMob(currentMob)
                    end
                end
            end
        end
    end)

    RunService.RenderStepped:Connect(function()
        if not isAutoMob or not hrp then return end
        if not isValidMob(currentMob) then return end

        local hrpMob = currentMob:FindFirstChild("HumanoidRootPart")
        if not hrpMob then return end

        hrp.CFrame = CFrame.new(hrpMob.Position + FLOAT_OFFSET)
        hrp.AssemblyLinearVelocity = Vector3.zero
        stabilizeHumanoid()
        lockCamera()
    end)

    ------------- /////// AUTO DUNGEON \\\\\\\ -------------
    local startDungeonRemote =
        ReplicatedStorage:WaitForChild("Remote")
        :WaitForChild("Event")
        :WaitForChild("Dungeon")
        :WaitForChild("[C-S]StartDungeon")

    local leaveCFrames = {
        Vector3.new(191.491989, 320.884583, 5471.39893),
        Vector3.new(499.325012, 320.909332, 5471.39844)
    }

    local leaveCFrames = {
        Vector3.new(191.491989, 320.884583, 5471.39893),
        Vector3.new(499.325012, 320.909332, 5471.39844)
    }

    local function isInDungeon()
        local gui = player:WaitForChild("PlayerGui"):WaitForChild("Info")
        local holder = gui:WaitForChild("DungeonHolder")
        return holder.Visible
    end

    local function getDoorPartPositions()
        local positions = {}
        local dungeonsFolder = workspace:WaitForChild("Dungeons")
        local playerDungeon = dungeonsFolder:FindFirstChild(player.Name)

        if playerDungeon then
            local doorPartFolder = playerDungeon:FindFirstChild("DoorPart")
            if doorPartFolder then
                local door0 = doorPartFolder:FindFirstChild("0")
                local door1 = doorPartFolder:FindFirstChild("1")

                if door0 then positions[1] = door0.Position end
                if door1 then positions[2] = door1.Position end
            end
        end

        return positions
    end

    local function getTeleportPosition()
        local fallback1 = Vector3.new(-1245.79907, 320.884583, 5471.39893)
        local fallback2 = Vector3.new(-937.966064, 320.909332, 5471.39844)

        if not hrp then
            return fallback1
        end

        local doorPositions = getDoorPartPositions()
        local POSITION_1 = doorPositions[1] or fallback1
        local POSITION_2 = doorPositions[2] or fallback2

        local currentX = hrp.Position.X
        local distance1 = math.abs(currentX - POSITION_1.X)
        local distance2 = math.abs(currentX - POSITION_2.X)

        return distance1 < distance2 and POSITION_1 or POSITION_2
    end

    local function pressE()
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.E, false, game)
        task.wait(0.1)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.E, false, game)
    end

    local function waitForNoMobsSafe()
        local timeout = 30
        local startTime = os.clock()

        while isAutoDungeon do
            local mobCount = 0
            for _, mob in ipairs(mobFolder:GetChildren()) do
                if mob:IsA("BasePart") then
                    local health = mob:GetAttribute("Health")
                    if health and health > 0 then
                        mobCount += 1
                    end
                end
            end

            if mobCount == 0 then
                return true
            end

            if os.clock() - startTime > timeout then
                warn("Auto Dungeon: mob wait timeout, forcing continue")
                return false
            end

            task.wait(0.5)
        end

        return false
    end

    local function startDungeon()
        startDungeonRemote:FireServer(startFloor)
    end

    local function getCurrentFloor()
        local gui = player:WaitForChild("PlayerGui"):WaitForChild("Info")
        local dungeonHolder = gui:WaitForChild("DungeonHolder")
        local levelLabel = dungeonHolder:WaitForChild("Active"):WaitForChild("LevelLabel")
        local text = levelLabel.Text or ""
        local floor = text:match("%d+")
        return tonumber(floor) or 0
    end

    local function getClosestLeaveCFrame()
        if not hrp then return leaveCFrames[1] end
        local pos = hrp.Position
        local distance1 = (pos - leaveCFrames[1]).Magnitude
        local distance2 = (pos - leaveCFrames[2]).Magnitude
        local closest = distance1 < distance2 and leaveCFrames[1] or leaveCFrames[2]

        return Vector3.new(closest.X, closest.Y + 3, closest.Z)
    end

    local function leaveDungeon()
        if not hrp then return end
        while isAutoDungeon and isAutoLeave and isInDungeon() do
            hrp.CFrame = CFrame.new(getClosestLeaveCFrame())
            task.wait(0.2)
            pressE()
            task.wait(0.5)
            if not isInDungeon() then
                break
            end
        end
    end

    local function autoDungeonLoop()
        while isAutoDungeon do
            local currentFloor = getCurrentFloor()

            if isAutoLeave and leaveFloor > 0 and currentFloor >= leaveFloor then
                leaveDungeon()
                task.wait(1)
            end

            if not isInDungeon() then
                startDungeon()
                task.wait(3)
            end

            while isAutoDungeon and isInDungeon() do
                local cleared = waitForNoMobsSafe()
                if not cleared or not isAutoDungeon then break end
                currentFloor = getCurrentFloor()
                
                if isAutoLeave and leaveFloor > 0 and currentFloor >= leaveFloor then
                    leaveDungeon()
                    task.wait(1)
                    break
                end

                if isAutoLeave and leaveFloor > 0 and currentFloor >= leaveFloor then
                    leaveDungeon()
                    task.wait(1)
                    break 
                elseif currentFloor >= 200 then
                    if hrp then
                        hrp.CFrame = CFrame.new(getClosestLeaveCFrame())
                    end
                    task.wait(0.2)
                    pressE()
                    task.wait(2)
                else
                    if hrp then
                        hrp.CFrame = CFrame.new(getTeleportPosition())
                    end
                    task.wait(0.5)
                    pressE()
                    task.wait(2)
                end
            end
            task.wait(1)
        end
    end

    ------------- /////// AUTO BLOCK \\\\\\\ -------------
    local blockRemote = ReplicatedStorage:WaitForChild("Remote"):WaitForChild("Event"):WaitForChild("Combat"):WaitForChild("Block")
    local blockGui = playerGui:WaitForChild("Hud"):WaitForChild("Bottom"):WaitForChild("Main"):WaitForChild("SkillBar"):WaitForChild("Block"):WaitForChild("BG"):WaitForChild("Yes")

    local function checkAndBlock()
        if isAutoBlock then
            if blockGui.Enabled == false then
                blockRemote:FireServer(true)
            end
        end
    end

    RunService.RenderStepped:Connect(checkAndBlock)

    ------------- /////// AUTO SKILLS \\\\\\\ -------------
    local TryReleaseSkill =
        ReplicatedStorage.Remote.Event.SkillTree:WaitForChild("[C-S]TryReleaseSkill")

    local SkillDamage =
        ReplicatedStorage.Remote.Event.Skill:WaitForChild("[C-S]SkillDamage")

    local SkillMap = {
        ["Swirl"] = "S1",
        ["Sword Dance"] = "S2",
        ["Blade Furry"] = "S3",
        ["Scarlet Sweep"] = "S4",
        ["Claw"] = "S5",
        ["Continuous Stabbing"] = "S6",
        ["Dimensional Slash"] = "S7",
        ["Infinite Sword Technique"] = "S8",
        ["Leap Attack"] = "S9",
        ["Chaos Slash"] = "S10",
        ["Returning to Silence"] = "S11",
        ["Trial Sword Rain"] = "S12",
    }

    local SkillCooldown = {
        ["Swirl"] = 20,
        ["Sword Dance"] = 30,
        ["Blade Furry"] = 30,
        ["Scarlet Sweep"] = 30,
        ["Claw"] = 20,
        ["Continuous Stabbing"] = 20,
        ["Dimensional Slash"] = 20,
        ["Infinite Sword Technique"] = 30,
        ["Leap Attack"] = 15,
        ["Chaos Slash"] = 30,
        ["Returning to Silence"] = 30,
        ["Trial Sword Rain"] = 30,
    }

    local lastUsed = {}

    local function getHRP()
        local char = player.Character
        return char and char:FindFirstChild("HumanoidRootPart")
    end

    local function isMobAlive(mob)
        return mob
            and mob.Parent
            and mob:GetAttribute("Health")
            and mob:GetAttribute("Health") > 0
            and mob:IsA("BasePart")
    end

    task.spawn(function()
        while true do
            if isAutoSkills and #selectedSkills > 0 then
                local hrp = getHRP()
                if hrp then
                    local mobsToAttack = {}

                    for _, mob in ipairs(mobFolder:GetChildren()) do
                        if isMobAlive(mob) then
                            local dist = (hrp.Position - mob.Position).Magnitude
                            if dist <= ATTACK_RANGE then
                                for i = 1, TABLE_ADD_AMOUNT do
                                    table.insert(mobsToAttack, mob.Name)
                                end
                            end
                        end
                    end

                    if #mobsToAttack > 0 then
                        local currentTime = tick()
                        for _, skillName in ipairs(selectedSkills) do
                            if not isAutoSkills then break end

                            local skillId = SkillMap[skillName]
                            local cooldown = SkillCooldown[skillName] or 0
                            local last = lastUsed[skillName] or 0

                            if skillId and (currentTime - last >= cooldown) then
                                TryReleaseSkill:FireServer(skillId)
                                task.wait(0.12)
                                SkillDamage:FireServer(skillId, mobsToAttack)
                                task.wait(0.25)
                                lastUsed[skillName] = tick()
                            end
                        end
                    end
                end
            end
            task.wait(1 / AttackPerSecond)
        end
    end)

    ------------- /////// EGGS \\\\\\\ -------------
    local EggsFolder = ReplicatedStorage:WaitForChild("Assets"):WaitForChild("Eggs")

    local EggOptions = {}

    for _, eggModel in ipairs(EggsFolder:GetChildren()) do
        if eggModel:IsA("Model") then
            table.insert(EggOptions, eggModel.Name)
        end
    end

    table.sort(EggOptions)

    ------------- /////// AUTO REBIRTH \\\\\\\ -------------
    local RebirthGui = playerGui:WaitForChild("Main")
        :WaitForChild("Rebirth")
        :WaitForChild("Main")
        :WaitForChild("Info")
        :WaitForChild("Bar")

    local CoinProgress = RebirthGui:WaitForChild("Coin")
        :WaitForChild("Bar")
        :WaitForChild("Progress")

    local LevelProgress = RebirthGui:WaitForChild("Level")
        :WaitForChild("Bar")
        :WaitForChild("Progress")

    local RebirthRemote = ReplicatedStorage
        :WaitForChild("Remote")
        :WaitForChild("Event")
        :WaitForChild("Rebirth")
        :WaitForChild("[C-S]TryRebirth")

    local function canRebirth()
        return CoinProgress.Text == "100%" and LevelProgress.Text == "100%"
    end

    local function autoRebirthLoop()
        while isAutoRebirth do
            if canRebirth() then
                RebirthRemote:FireServer()

                repeat
                    task.wait(1)
                until not canRebirth() or not isAutoRebirth
            end

            task.wait(30)
        end
    end

    ------------- /////// AUTO SOCKET \\\\\\\ -------------
    local craftRemote =
        ReplicatedStorage
            :WaitForChild("Remote")
            :WaitForChild("Function")
            :WaitForChild("Socket")
            :WaitForChild("[C-S]CraftSocket")

    local socketMap = {
        ["Ruby"] = "G1",
        ["Excellence Ruby"] = "G2",
        ["Perfect Ruby"] = "G3",
        ["Chaos Ruby"] = "G17",

        ["Emerald"] = "G4",
        ["Excellence Emerald"] = "G5",
        ["Perfect Emerald"] = "G6",

        ["Diamond"] = "G7",
        ["Excellence Diamond"] = "G8",
        ["Perfect Diamond"] = "G9",
        ["Infinite Diamond"] = "G18",

        ["Amethyst"] = "G10",
        ["Excellence Amethyst"] = "G11",
        ["Perfect Amethyst"] = "G12",

        ["Sapphire"] = "G13",
        ["Excellence Sapphire"] = "G14",
        ["Perfect Sapphire"] = "G15",
        ["Forever Sapphire"] = "G16",
    }

    local orderedSocketNames = {
        -- Ruby line
        "Ruby",
        "Excellence Ruby",
        "Perfect Ruby",
        "Chaos Ruby",

        -- Emerald line
        "Emerald",
        "Excellence Emerald",
        "Perfect Emerald",

        -- Diamond line
        "Diamond",
        "Excellence Diamond",
        "Perfect Diamond",
        "Infinite Diamond",

        -- Amethyst line
        "Amethyst",
        "Excellence Amethyst",
        "Perfect Amethyst",

        -- Sapphire line
        "Sapphire",
        "Excellence Sapphire",
        "Perfect Sapphire",
        "Forever Sapphire",
    }

    local socketOptions = {"ALL"}
    for _, socketName in ipairs(orderedSocketNames) do
        table.insert(socketOptions, socketName)
    end

    local allFragments = {}
    for _, socketName in ipairs(orderedSocketNames) do
        local fragmentId = socketMap[socketName]
        if fragmentId then
            table.insert(allFragments, fragmentId)
        end
    end

    local function parseAmount(text)
        local numberPart, suffix = text:match("([%d%.]+)([KM]?)")
        local amount = tonumber(numberPart) or 0

        if suffix == "K" then
            amount = amount * 1000
        elseif suffix == "M" then
            amount = amount * 1000000
        end

        return math.floor(amount)
    end

    local function getFragmentAmount(fragmentName)
        local gui = player.PlayerGui:FindFirstChild("Main")
        if not gui then return 0 end

        local scrollingFrame =
            gui.Socket.Main.Info.Craft.ScrollingFrame.List

        local fragmentFrame = scrollingFrame:FindFirstChild(fragmentName)
        if fragmentFrame then
            local button = fragmentFrame:FindFirstChild("Button")
            local amountLabel = button and button:FindFirstChild("Amount")

            if amountLabel and amountLabel:IsA("TextLabel") then
                return parseAmount(amountLabel.Text)
            end
        end

        return 0
    end

    local function craftFragment(fragmentName)
        craftRemote:InvokeServer({fragmentName, fragmentName, fragmentName})
    end

    local function getSelectedFragments()
        if not isAutoCraftSocket then
            return {}
        end

        if table.find(selectedSocket, "ALL") then
            return allFragments
        end

        local fragments = {}
        for _, socketName in ipairs(selectedSocket) do
            local fragmentId = socketMap[socketName]
            if fragmentId then
                table.insert(fragments, fragmentId)
            end
        end

        return fragments
    end

    task.spawn(function()
        while true do
            if isAutoCraftSocket then
                local crafted = false
                local fragmentsToUse = getSelectedFragments()

                for _, fragmentName in ipairs(fragmentsToUse) do
                    if getFragmentAmount(fragmentName) >= 3 then
                        craftFragment(fragmentName)
                        crafted = true
                        task.wait(0.05)
                    end
                end

                if not crafted then
                    task.wait(0.1)
                end
            else
                task.wait(0.1)
            end
        end
    end)

    ------------- /////// AUTO SELL \\\\\\\ -------------
    local backpackGui = player.PlayerGui:WaitForChild("Main"):WaitForChild("Backpack")
    local infoGui = backpackGui:WaitForChild("Main"):WaitForChild("Info")
    local listFrame = infoGui:WaitForChild("List"):WaitForChild("Equip"):WaitForChild("ScrollingFrame")

    local sellRemote = ReplicatedStorage:WaitForChild("Remote"):WaitForChild("Event"):WaitForChild("Item"):WaitForChild("[C-S]DeleteList")

    local function getUnlockedItems()
        local unlockedItems = {}
        for _, frame in ipairs(listFrame:GetChildren()) do
            if frame:IsA("Frame") then
                local button = frame:FindFirstChild("Button")
                if button then
                    local lock = button:FindFirstChild("Lock")
                    if lock and not lock.Visible then
                        unlockedItems[frame.Name] = true
                    end
                end
            end
        end
        return unlockedItems
    end

    local function sellUnlockedItems()
        local itemsToSell = getUnlockedItems()
        if next(itemsToSell) then
            sellRemote:FireServer(itemsToSell)
            print("Sold items:", itemsToSell)
        else
            print("No unlocked items to sell.")
        end
    end

    RunService.Heartbeat:Connect(function()
        if isAutoSell then
            local totalItems = 0
            for _, frame in ipairs(listFrame:GetChildren()) do
                if frame:IsA("Frame") then
                    totalItems = totalItems + 1
                end
            end

            if totalItems >= autoSellThreshold then
                sellUnlockedItems()
            end
        end
    end)

    ------------- /////// AUTO SELL RELIC \\\\\\\ -------------
    local relicScrollingFrame =
        player.PlayerGui
        :WaitForChild("Main")
        :WaitForChild("Backpack")
        :WaitForChild("Main")
        :WaitForChild("Info")
        :WaitForChild("List")
        :WaitForChild("Relic")
        :WaitForChild("List")
        :WaitForChild("ScrollingFrame")

    local relicDeleteRemote =
        ReplicatedStorage
        :WaitForChild("Remote")
        :WaitForChild("Event")
        :WaitForChild("Relic")
        :WaitForChild("[C-S]DeleteList")

    local TARGET_ICON_IDS = {
        ["rbxassetid://132432429926779"] = true,
        ["rbxassetid://112614629953647"] = true,
        ["rbxassetid://91189434116621"] = true,
        ["rbxassetid://136285583869655"] = true,
    }

    local function deleteRelics()
        local relicsToDelete = {}

        for _, frame in ipairs(relicScrollingFrame:GetChildren()) do
            if frame:IsA("Frame") then
                local button = frame:FindFirstChild("Button")
                if button then
                    local icon = button:FindFirstChild("Icon")
                    if icon and TARGET_ICON_IDS[icon.Image] then
                        relicsToDelete[frame.Name] = true
                    end
                end
            end
        end

        if next(relicsToDelete) then
            relicDeleteRemote:FireServer(relicsToDelete)
        end
    end

    RunService.Heartbeat:Connect(function()
        if isAutoDeleteRelic then
            deleteRelics()
        end
    end)

    ------------- /////// EVENT ENCHANT \\\\\\\ -------------
    local enchantFunction = ReplicatedStorage
        :WaitForChild("Remote")
        :WaitForChild("Function")
        :WaitForChild("Enchant")
        :WaitForChild("[C-S]TryEnchant")

    local scrollingFrame =
        player.PlayerGui
        :WaitForChild("Main")
        :WaitForChild("Enchant")
        :WaitForChild("Main")
        :WaitForChild("Info")
        :WaitForChild("ScrollingFrame")

    local function startAutoEnchant()
        if autoEnchantThread then return end

        autoEnchantThread = task.spawn(function()
            while isAutoEnchantFast do
                local uuids = {}

                for _, frame in ipairs(scrollingFrame:GetChildren()) do
                    if frame:IsA("Frame") then
                        table.insert(uuids, frame.Name)
                    end
                end

                if #uuids > 0 then
                    local uuid = uuids[math.random(#uuids)]
                    enchantFunction:InvokeServer(uuid, 1, 1)
                end

                task.wait(0.1)
            end

            autoEnchantThread = nil
        end)
    end

    ------------- /////// EVENT MATERIALS \\\\\\\ -------------
    local Maps = {
        Vector3.new(5428.95557, 38.2745056, 328.413879),   -- map1
        Vector3.new(7999.55957, 173.274399, 536.513916), -- map2
        Vector3.new(13213.1387, 1.64267349, 22.4399719)  -- map3
    }

    local ClanResource = Workspace:WaitForChild("ClanResource")

    local function forcePrompt(v)
        if v:IsA("ProximityPrompt") then
            v.HoldDuration = 0
        end
    end

    for _, v in ipairs(Workspace:GetDescendants()) do
        forcePrompt(v)
    end

    Workspace.DescendantAdded:Connect(forcePrompt)

    local function teleportTo(pos)
        hrp.CFrame = CFrame.new(pos + Vector3.new(0, 3, 0))
        task.wait(0.25)
    end

    local function pressE()
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.E, false, game)
        task.wait(0.05)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.E, false, game)
    end

    local function collectResources()
        for _, resourceFolder in ipairs(ClanResource:GetChildren()) do
            if not isAutoMaterials then return end

            for _, spot in ipairs(resourceFolder:GetChildren()) do
                if not isAutoMaterials then return end

                if spot:IsA("Part") then
                    for _, model in ipairs(spot:GetChildren()) do
                        if not isAutoMaterials then return end

                        if model:IsA("Model") then
                            local part = model:FindFirstChildWhichIsA("BasePart")
                            if part then
                                teleportTo(part.Position)
                                pressE()
                                task.wait(0.15)
                            end
                        end
                    end
                end
            end
        end
    end

    local function startAutoMaterials()
        if autoThread then return end

        autoThread = task.spawn(function()
            while isAutoMaterials do
                for _, mapPos in ipairs(Maps) do
                    if not isAutoMaterials then break end
                    teleportTo(mapPos)
                    task.wait(0.4)
                    collectResources()
                end
                task.wait(1.5)
            end
            autoThread = nil
        end)
    end

    ------------- /////// UI STUFF \\\\\\\ -------------
    local Window = getgenv().Window
    local Event = Window:CreateTab("Event", "calendar-clock")
    local Tab = Window:CreateTab("Main", "swords")
    local Upgrade = Window:CreateTab("Upgrade", "shield-plus")
    local Dungeon = Window:CreateTab("Dungeon", "tower-control")
    local Egg = Window:CreateTab("Egg", "egg")
    local Teleport = Window:CreateTab("Teleport", "map")

    ------------- /////// FUNCTIONS \\\\\\\ -------------
    Event:CreateSection("Upgrade Section")
    Event:CreateToggle({
        Name = "Auto Enchant Fast",
        CurrentValue = false,
        Flag = "autoenchantfasttoggle",
        Callback = function(Value)
            isAutoEnchantFast = Value

            if Value then
                startAutoEnchant()
            end
        end,
    })

    Event:CreateSection("Materials Section")
    Event:CreateToggle({
        Name = "Auto Collect Materials (CD)",
        CurrentValue = false,
        Flag = "automaterialstoggle",
        Callback = function(Value)
            isAutoMaterials = Value
            if Value then
                startAutoMaterials()
            end
        end,
    })

    Event:CreateSection("Egg Section")
    Event:CreateToggle({
        Name = "Auto Claim Rewards",
        CurrentValue = false,
        Flag = "autoeventclaimtoggle",
        Callback = function(Value)
            isAutoEventClaim = Value
            if Value then
                spawn(function()
                    while isAutoEventClaim do
                        local remote = game:GetService("ReplicatedStorage")
                            :WaitForChild("Remote")
                            :WaitForChild("Event")
                            :WaitForChild("Xmas25")
                            :WaitForChild("[C-S]TryClaimQuestReward")
                        
                        remote:FireServer("SQ19")
                        remote:FireServer("SQ17")
                        task.wait(0.1)
                    end
                end)
            end
        end,
    })

    Event:CreateToggle({
        Name = "Auto Christmas Egg",
        CurrentValue = false,
        Flag = "autoeventeggtoggle",
        Callback = function(Value)
            isAutoEventEgg = Value
            if Value then
                spawn(function()
                    while isAutoEventEgg do
                        local args = {"RW12"}
                        game:GetService("ReplicatedStorage")
                            :WaitForChild("Remote")
                            :WaitForChild("Event")
                            :WaitForChild("Xmas25")
                            :WaitForChild("[C-S]TryExchangeReward")
                            :FireServer(unpack(args))
                        task.wait(0.1)
                    end
                end)
            end
        end,
    })

    Tab:CreateSection("Farm Section")
    Tab:CreateToggle({
        Name = "Kill Aura",
        CurrentValue = false,
        Flag = "killauratoggle",
        Callback = function(Value)
            isKillAura = Value
            if not Value then
                currentTarget = nil
            end
        end,
    })

    Tab:CreateToggle({
        Name = "Kill Aura Player",
        CurrentValue = false,
        Flag = "killauraplayertoggle",
        Callback = function(Value)
            isKillAuraPlayer = Value
        end,
    })

    Tab:CreateToggle({
        Name = "Auto Mob",
        CurrentValue = false,
        Flag = "automobtoggle",
        Callback = function(Value)
            isAutoMob = Value
        end,
    })

    Tab:CreateSection("Skills Section")
    Tab:CreateDropdown({
    Name = "Select Skills",
    Options = {
        "Swirl","Sword Dance","Blade Furry","Scarlet Sweep","Claw",
        "Continuous Stabbing","Dimensional Slash","Infinite Sword Technique","Leap Attack",
        "Chaos Slash","Returning to Silence","Trial Sword Rain"
    },
    CurrentOption = "",
    MultipleOptions = true,
    Flag = "skilldropdown",
    Callback = function(Options)
        selectedSkills = Options
    end,
    })

    Tab:CreateToggle({
        Name = "Auto Skills",
        CurrentValue = false,
        Flag = "autoskillstoggle",
        Callback = function(Value)
            isAutoSkills = Value
        end,
    })

    Tab:CreateSection("Player Section")
    Tab:CreateToggle({
        Name = "Auto Block",
        CurrentValue = false,
        Flag = "autoblocktoggle",
        Callback = function(Value)
            isAutoBlock = Value
        end,
    })

    Tab:CreateToggle({
        Name = "Auto Rebirth",
        CurrentValue = false,
        Flag = "autorebirthtoggle",
        Callback = function(Value)
            isAutoRebirth = Value

            if Value then
                if not checkingThread then
                    checkingThread = task.spawn(autoRebirthLoop)
                end
            else
                checkingThread = nil
            end
        end,
    })

    Tab:CreateSection("Sell Section")
    Tab:CreateInput({
        Name = "Auto Sell At:",
        CurrentValue = tostring(autoSellThreshold),
        PlaceholderText = "How many items before sell",
        RemoveTextAfterFocusLost = false,
        Flag = "AutoSellInput",
        Callback = function(Text)
            local number = tonumber(Text)
            if number and number > 0 then
                autoSellThreshold = number
            else
                warn("Invalid number for Auto Sell threshold")
            end
        end,
    })

    Tab:CreateToggle({
        Name = "Auto Sell Items",
        CurrentValue = false,
        Flag = "autoselltoggle",
        Callback = function(Value)
            isAutoSell = Value
        end,
    })

    Tab:CreateToggle({
        Name = "Auto Sell Relics",
        CurrentValue = false,
        Flag = "autodeleterelictoggle",
        Callback = function(Value)
            isAutoDeleteRelic = Value
            hasDeleted = false
        end,
    })

    Upgrade:CreateSection("Stats Section")
    Upgrade:CreateDropdown({
    Name = "Select Upgrade",
    Options = {"Damage","Defense","Health"},
    CurrentOption = "",
    MultipleOptions = false,
    Flag = "upgradedropdown",
    Callback = function(Options)
        selectedUpgrade = Options[1]
    end,
    })

    Upgrade:CreateToggle({
        Name = "Auto Upgrade",
        CurrentValue = false,
        Flag = "autoupgradetoggle",
        Callback = function(Value)
            isAutoUpgrade = Value
            if isAutoUpgrade then
                task.spawn(function()
                    while isAutoUpgrade do
                        local args = {
                            selectedUpgrade,
                            1
                        }
                        game:GetService("ReplicatedStorage"):WaitForChild("Remote"):WaitForChild("Event"):WaitForChild("Upgrade"):WaitForChild("[C-S]TryAddPoint"):FireServer(unpack(args))
                        task.wait(0.1)
                    end
                end)
            end
        end,
    })

    Upgrade:CreateSection("Forge Section")
    Upgrade:CreateDropdown({
        Name = "Select Socket:",
        Options = socketOptions,
        CurrentOption = {},
        MultipleOptions = true,
        Flag = "socketdropdown",
        Callback = function(Options)
            selectedSocket = Options
        end,
    })

    Upgrade:CreateToggle({
        Name = "Auto Craft Socket",
        CurrentValue = false,
        Flag = "autocraftsockettoggle",
        Callback = function(Value)
            isAutoCraftSocket = Value
        end,
    })

    Upgrade:CreateSection("Enchant Section")
    Upgrade:CreateDropdown({
    Name = "Select Item",
    Options = {"Weapon","Armour","Foot"},
    CurrentOption = "",
    MultipleOptions = false,
    Flag = "enchantitemdropdown",
    Callback = function(Options)
        selectedEnchantItem = Options[1]
    end,
    })

    Upgrade:CreateButton({
        Name = "Change Enchant List",
        Callback = function()
            local remote = ReplicatedStorage
                :WaitForChild("Remote")
                :WaitForChild("Event")
                :WaitForChild("Enchant")
                :WaitForChild("[C-S]TryFrushEnchantResult")

            local scrollingFrame =
                player.PlayerGui
                :WaitForChild("Main")
                :WaitForChild("Enchant")
                :WaitForChild("Main")
                :WaitForChild("Info")
                :WaitForChild("ScrollingFrame")

            local validItems = {}

            for _, frame in ipairs(scrollingFrame:GetChildren()) do
                if frame:IsA("Frame") then
                    local id = frame:GetAttribute("Id")
                    local itemType = frame:GetAttribute("Type")

                    if id and itemType then
                        table.insert(validItems, {
                            uuid = frame.Name,
                            id = id,
                            type = itemType
                        })
                    end
                end
            end

            if #validItems > 0 then
                local item = validItems[math.random(#validItems)]

                local args = {
                    {
                        type = item.type,
                        Health = 0,
                        lock = true,
                        id = item.id,
                        uuid = item.uuid,
                        Defense = 0
                    },
                    selectedEnchantItem
                }

                remote:FireServer(unpack(args))
            end
        end,
    })

    Dungeon:CreateSection("Dungeon Section")
    Dungeon:CreateInput({
        Name = "Start Floor:",
        CurrentValue = "",
        PlaceholderText = "Enter Start Floor",
        RemoveTextAfterFocusLost = false,
        Flag = "startfloorinput",
        Callback = function(Text)
            startFloor = tonumber(Text) or 1
        end,
    })
    
    Dungeon:CreateInput({
        Name = "Leave Floor:",
        CurrentValue = "",
        PlaceholderText = "Enter Floor Number",
        RemoveTextAfterFocusLost = false,
        Flag = "leavefloorinput",
        Callback = function(Text)
            leaveFloor = tonumber(Text) or 0
        end,
    })

    Dungeon:CreateToggle({
        Name = "Auto Leave",
        CurrentValue = false,
        Flag = "autoleavetoggle",
        Callback = function(Value)
            isAutoLeave = Value
        end,
    })

    Dungeon:CreateToggle({
        Name = "Auto Dungeon",
        CurrentValue = false,
        Flag = "autodungeontoggle",
        Callback = function(Value)
            isAutoDungeon = Value

            if Value then
                if dungeonThread then
                    task.cancel(dungeonThread)
                end
                dungeonThread = task.spawn(autoDungeonLoop)
            else
                if dungeonThread then
                    task.cancel(dungeonThread)
                    dungeonThread = nil
                end
            end
        end,
    })

    Egg:CreateSection("Egg Section")
    Egg:CreateDropdown({
    Name = "Select Egg",
    Options = EggOptions,
    CurrentOption = "",
    MultipleOptions = false,
    Flag = "eggdropdown",
    Callback = function(Options)
        selectedEgg = Options[1]
    end,
    })

    Egg:CreateToggle({
        Name = "Auto Buy Selected Egg",
        CurrentValue = false,
        Flag = "autobuydungeoneggtoggle",
        Callback = function(Value)
            isAutoDungeonEgg = Value
            if isAutoDungeonEgg then
                task.spawn(function()
                    while isAutoDungeonEgg do
                        local args = {
                            selectedEgg,
                            1
                        }
                        game:GetService("ReplicatedStorage")
                            :WaitForChild("Remote")
                            :WaitForChild("Function")
                            :WaitForChild("Luck")
                            :WaitForChild("[C-S]DoLuck")
                            :InvokeServer(unpack(args))
                        task.wait(0.1)
                    end
                end)
            end
        end,
    })

    Teleport:CreateSection("Map Section")
    Teleport:CreateDropdown({
    Name = "Select Map",
    Options = {
        "World 1", "World 2", "World 3", "World 4",
        "World 5", "World 6", "World 7", "World 9",
        "Dungeon"
    },
    CurrentOption = "",
    MultipleOptions = false,
    Flag = "teleportdropdown",
    Callback = function(Options)
        selectedMap = Options[1]
    end,
    })

    Teleport:CreateButton({
        Name = "Teleport To Selected Map",
        Callback = function()
            if not selectedMap or selectedMap == "" then
                warn("No map selected")
                return
            end

            local mapId = mapNames[selectedMap]
            if not mapId then
                warn("Invalid map selected:", selectedMap)
                return
            end

            game:GetService("ReplicatedStorage")
                :WaitForChild("Remote")
                :WaitForChild("Event")
                :WaitForChild("World")
                :WaitForChild("[c-s]TryGoWorld")
                :FireServer(tonumber(mapId))

            Notify("Teleported To: " .. selectedMap .. " map", "", "map")
        end,
    })

    getgenv().CreateUniversalTabs()
end
